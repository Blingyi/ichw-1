# Q1.

---

(以下选自：1800011717 王泽锟)

- 图灵证明停机问题的根本目的是为了证明Hilbert's tenth problem，即  

> 能否找到一种普遍的算法，可用来判定一个任意形式的丢番图方程是否有整数解 

他据此设计了图灵机，由于图灵机的纸带无限长，理论上它能够实现任何可能的运算。既然图灵机覆盖了任何可能的数学运算过程，那么如果存在图灵机无法判断的过程，那这个问题答案自然是没有普遍的算法。据此，图灵设计了停机问题，简单的说法即“是否有程序能够判断任何其他程序能否在有限的时间内中止运行”。他通过证明停机问题中的假想程序不存在，从而给出了Hilbert's tenth problem的答案。  

---

(以下选自：1800011718 孙鹏伟)

图灵对停机问题的证明正是对希尔伯特提出的问题之一（能否存在一种通用的机械过程，能够判断任何数学命题的真假）的证明，也是对第三次数学危机的尝试解决，又与哥德尔不完备性定理相呼应，如果能创造出来一个万能程序，即可解决许多当时无法证明的数学问题。

以哥德巴赫猜想为例，设计出来一个程序，枚举偶数并寻找两个质数相加等于这个偶数，如果找到了则跳转到下一个偶数继续寻找，如果找不到则停机。然后用万能程序即可判断刚才的证明程序是否会停机，如果不会停机，则相当于证明了哥德巴赫猜想，如果会停机，则相当于推翻了哥德巴赫猜想。

---

图灵利用反证法证明了停机问题，详细证明参考讲义。

---

(以下选自：1700017785 李鸿宇)

在数学原理上，该方法也称为康托尔对角线方法。
假设我们可以将任意图灵机**Ti**在任意可能输入**Ii**下是否停机的情况列成一张表（基于图灵机的可列性）：

|halt|I1|I2|I3|…|In|…|
|---|---|---|---|---|---|---|
|T1|n|y|n|…|y|…|
|T2|y|n|n|…|y|…|
|T3|y|y|y|…|y|…|
|…|
|Tn|n|n|n|…|y|…|
|…|

现在构造一台新的图灵机**P**，它与图灵机**Tk**在输入**Ik**下的停机状况不同，即
```
if Tk(Ik) == y:
	P(Ik) = n
else:
	P(Ik) = y
```
那么P与以上任意一台图灵机均不同。这说明我们并不能判定所有图灵机的停机情况，即“停机问题”不可解。 

---

(以下选自：1800011758 常睿)

**数学原理**：哥德尔不完备性定理，命题P“P不可在系统T内证明”这个正确命题不可以在系统T内被证明。假设T可以证明出P，而因为P说的就是P不可在系统内被证明，矛盾。所以T不能证明P，P这个正确命题不可以在系统T内被证明。

---

# Q2.

---

(以下选自1800011701 牛潇)

补码是计算机中用来表示负数，使得负数能够使用加法器参与加法运算的一种码，

也就是说补码可以把加减法统一起来，让减法也可以按照加法的规则运算，即减去一个数等于加上它的相反数（补码）。

那么如何求一个数的补码？

简单地说就是规定的模减去这个数。

举个例子，假如一个时钟现在显示的是7点，如何将它调到4点？有两种方法：向前拨9个小时，或者向后拨3个小时。

此时9+3=12，12是模，9和3就互为补码。7-3和7+（12-3）的结果是一样的。

可是7+（12-3）不应该等于16吗？是的，但是你的钟并没有地方存储这多余的12个小时，

换句话说，你把这溢出的12个小时自动舍弃了。当第二个人来查看时钟时间的时候，他看到的时间就是准的。

在二进制中，正数的补码仍然是它本身。

负数补码的求法是：将该二进制数的各位（不考虑符号位）逐一求反，再加1，即得到该数的补码。如101101的补码求法即为:求反，得110010，加1，得110011，即为其补码。

为什么可以这么求呢？观察上面的例子，不考虑符号位，10011+01101=100000，就等于5位二进制的模。

所以在计算减法的时候，可以直接用加上补码的操作代替减去某个值。如15-10 要想让减法变加法，必须转换算式为 15+（-10）

15为正数，符号位为0，二进制表示为01111

-10为负数，符号位为1，负数源码为11010 ，补码符号位不变，其余逐位求反再 +1，即10110

所以 15+（-11）=01111+10110 = 100100，舍弃最高位（由于存储只限5位）溢出位，即00100，即+4

---

(以下选自1800011703 聂翊宸)

首先,我们先看不存在补码时,二进制下,整数的加法（整数用8位二进制数表示,第一位表示符号）：

|十进制运算|二进制运算|二进制结果|二进制结果转换成十进制|
|:-:|:-:|:-:|:-:|
|1+1|0000 0001+0000 0001|0000 0010|2|
|2+32|0000 0010+0010 0000|0010 0010|34|

可以看见,这并不存在什么问题.然而当我们在做减法,或负数的加法时：

|十进制运算|二进制运算|二进制结果|二进制结果转换成十进制|
|:-:|:-:|:-:|:-:|
|1+(-2)|0000 0001+1000 0010|1000 0011|-3|
|3+(-2)|0000 0011+1000 0010|1000 0101|-5|
|3+(-4)|0000 0011+1000 0100|1000 0111|-7|

这就出现问题了,1+(-2)或者说1-2应当等于-1,而按照这种算法,最后给出了-3.

这样的话,如果需要计算减法,则需要设计额外的程序电路,这无异于增大CPU的大小.

为了克服这一问题,补码应运而生.最简单的方法就是将计算过程变成：

1+(-2)=1+(126-128)=(1+126)-128=127-128=-1

换言之,如果有一个128个小格的钟表,上面表示1即指针顺时针转动1个小格.表示(-2)即逆时针转动2个小格,也就相当于顺时针转动126个小格.

在计算1+(-2)时,则先从指针指向0开始,顺时针先拨1小格,再拨126个小格,此时表上显示的应当是顺时针拨动127个小格,它可以表示127或(-1).随后我们再考虑第一位,得出最后的结果-1.

将-2转换为126的过程,在二进制中,就是一个求补码的过程.


在这之前,我们先引入反码的概念.在反码的计算中,符号位保持不变,其他位发生变化（1→0,0→1）.可以发现,一个负数除了符号位,其原码和反码之和,应为111 1111,也就是$2^7-1$.那么对于负数,先取绝对值后加上1,就可变成补码.而对于正数,前面的计算中正数加法是不存在任何问题的,所以正数的补码和反码规定与原码相同.

|原码|反码|补码|十进制表示|
|:-:|:-:|:-:|:-:|
|0000 0011|0000 0011|0000 0011|3|
|1000 0010|1111 1101|1111 1110|-2|

这时候我们用补码做计算,例如3-2:反码0000 0011+1111 1110=1 0000 0001,看似仿佛溢出了,但是如果不看溢出的1,剩下的0000 0001即是十进制数1的补码.

再例如3-4:0000 0011+1111 1100=1111 1111, 也就是-1的补码.

这样也就满足如果二进制下x,y,z为任意正负数,只要不发生溢出,那么,$x+y=z$那么$x_{补}+y_{补}=z_{补}$.使得无论加法减法，都可以同一逻辑电路下完成.

---

# Q3.

|Num|Sign|Exp|Frac|Value|
|:-:|:-:|:-:|:-:|:-:|
|0|*|000 0000|0000 0000|±0.0|
|1|0|011 1111|0000 0000|1.0|
|-1|1|011 1111|0000 0000|-1.0|
|最大非规范化数|*|000 0000|1111 1111|±（1-2<sup>-8</sup>)×2<sup>-62</sup>|
|最小非规范化数|*|000 0000|0000 0001|±2<sup>-8</sup>×2<sup>-62</sup>|
|最大规范化浮点数|*|111 1110|1111 1111|±（2-2<sup>-8</sup>)×2<sup>63</sup>|
|最小规范化浮点数|*|000 0001|0000 0000|±2<sup>-62</sup>|
|±∞|*|111 1111|0000 0000|±∞|
|NaN|*|111 1111|non zero|NaN|